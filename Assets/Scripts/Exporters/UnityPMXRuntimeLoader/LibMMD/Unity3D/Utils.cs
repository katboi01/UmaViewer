// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using UnityEngine;
using Object = UnityEngine.Object;

namespace LibMMD.Unity3D
{
	public class Utils
	{
		public static void UpdateFloatsToVector3(float[] f, Vector3[] dst) {
			var size = f.Length / 3;
			for (var i=0; i<size; i++) {
				var baseIndex = i * 3;
				dst[i].x = f[baseIndex];
				dst[i].y = f[baseIndex + 1];
				dst[i].z = f[baseIndex + 2];
			}
		}

		public static void MmdUvToUnityUv(float[] f, Vector2[] dst) {
			var size = f.Length / 2;
			for (var i=0; i<size; i++) {
				var baseIndex = i * 2;
				dst [i].x = f [baseIndex];
				dst [i].y = 1.0f - f [baseIndex + 1];
			}
		}

        public static Vector2[] MmdUvToUnityUv(float[] f)
        {
            var size = f.Length / 2;
            Vector2[] dst = new Vector2[size];
            for (var i = 0; i < size; i++)
            {
                var baseIndex = i * 2;
                dst[i].x = f[baseIndex];
                dst[i].y = 1.0f - f[baseIndex + 1];
            }

            return dst;
        }

        public static List<T> ArrayToList<T>(T[] src, int srcIndex, int length) {
			var ret = new List<T> (length);
			var endPos = srcIndex + length;
			for (var i=srcIndex; i<endPos; i++) {
				ret.Add(src[i]);
			}
			return ret;
		}

		public static Color FloatRgbaToColor(float[] rgba) {
			return new Color (rgba [0], rgba [1], rgba [2], rgba [3]);
		}


		public static Color[] Bgra32ToColors(byte[] bytes) {
			var pixelCount = bytes.Length / 4;
			var ret = new Color[pixelCount];
			for (var i = 0; i < pixelCount; i++) {
				var offset = i * 4;
				ret [i] = new Color (
					bytes [offset + 2] / 255.0f, 
					bytes [offset + 1] / 255.0f, 
					bytes [offset + 0] / 255.0f, 
					bytes [offset + 3] / 255.0f
				);
			}
			return ret;
		}
		
		public static void ClearAllTransformChild(Transform t) {
			var itemCount = t.childCount;
			for (var i = 0; i < itemCount; i++) {
				Object.Destroy (t.GetChild(i).gameObject);
			}
		}

		public static void DisposeIgnoreException(IDisposable disposable)
		{
			if (disposable == null)
			{
				return;
			}
			try
			{
				disposable.Dispose();
			}
			catch(Exception e)
			{
				Debug.LogException(e);
			}
		}
			
	}
}

